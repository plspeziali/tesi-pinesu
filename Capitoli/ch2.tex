Di seguito si introducono alcuni concetti 
per permettere al lettore di acquisire le nozioni necessarie alla
corretta fruizione del materiale successivo.

\section{Funzioni di hash}
\label{sub:hash}
Una \textbf{funzione di hashing}~\cite{hash} è un algoritmo che calcola una stringa di lunghezza
fissa a partire da una sequenza di dati di lunghezza variabile, come un file,
che altro non è che un insieme di blocchi di dati.
L’hashing trasforma questi dati in una stringa di lunghezza fissa, chiama \textbf{hash} o stringa di hash,
il cui valore rappresenta la stringa originale. Il valore della stringa può essere considerato
il riassunto di tutto il contenuto del file. Un hash è di solito una stringa esadecimale.

Un buon algoritmo di hashing possiede una proprietà chiamata \emph{effetto valanga},
ovvero la stringa di output cambia in maniera significativa o anche interamente anche
quando un singolo bit o byte di data viene modificato. Inoltre l’algoritmo deve essere
complesso abbastanza da non produrre lo stesso output per due diversi input, se ciò avviene
siamo in presenza di una \emph{collisione}. Una possibilità molto bassa di collisione è spesso
indice di un algoritmo solido. L’hashing è un’operazione unidirezionale, dalla stringa di hash
non si può risalire al file originale.
Uno dei tanti usi dello hashing è quello di confrontare due file per controllare se il loro contenuto
è lo stesso, in caso affermativo produrranno, per la stessa funzione, lo stesso hash,
possiamo quindi controllare in maniera immediata l’uguaglianza senza dover necessariamente
controllare l’intero file parola per parola.
Grazie a ciò è anche possibile controllare l’\textbf{integrità} di un file, se è stato infatti
modificato o manomesso esso produrrà una stringa di hash differente rispetto a quella che dovrebbe produrre.

\section{VCS e Git}
\label{sub:vcs}
Un \textbf{Version Control System}~\cite{vcs1} (o anche VCS), in italiano “sistema di controllo di versione”,
è una tipologia di software per la condivisione,
il controllo e la tracciabilità dei cambiamenti riguardanti determinati file e directory
lungo un lasso di tempo e che permette agli utenti di recuperare rapidamente specifiche
versioni dei loro documenti. Gli insiemi di file e cartelle gestite da questi sistemi
sono suddivisi in \textbf{repository}, esse vengono trattate l’una isolata dalle altre.
Spesso si considera una intera directory di lavoro, con il suo contenuto,
un’unica repository, potendo però scegliere di escludere alcune risorse.
Un VCS può essere centralizzato o distribuito~\cite{vcs2}.
Nel primo caso è il server centrale che tiene traccia dei cambiamenti e che mantiene e
distribuisce la versione più recente delle risorse richieste, gli utenti possono gestire
le loro repository solo attraverso client lightweight che interagiscono con il server
per riuscire a compiere una qualsiasi operazione.
Nel secondo caso ogni client ha una copia precisa della repository e del suo storico
salvata localmente, i server sono coinvolti solo per effettuare sincronizzazioni
di repository tra i vari client.
\\ 
\label{sub:git}
\textbf{Git}~\cite{git-21} è il sistema di controllo di versione distribuito più diffuso al mondo.
Esso modella ogni repository come una \emph{sequenza} o \emph{flusso di snapshot} (istantanee)
di un piccolo file system. Ogni volta che un utente salva lo stato del suo progetto
(tramite l’operazione di \emph{commit}) Git crea uno snapshot di tutti i file e le directory
sotto controllo di versione in quel momento e la archivia nel suo database locale, ogni
file modificato dall’ultimo commit viene incluso nell’ultimo snapshot, mentre i file che
non sono stati modificati non vengono inclusi se non con un collegamento alla loro versione identica
nel commit precedente, in modo da evitare alcuna duplicazione non necessaria.
Ogni risorsa in una repository è identificata internamente dal suo hash (\autoref{sub:hash}) e non dal suo nome,
questo permette a Git di individuare efficientemente i cambiamenti nei file.
Inoltre, quasi ogni operazione di Git va ad aggiungere informazioni al suo database, anche se si tratta
di un’operazione di rimozione, ciò assicura che ogni cambiamento sia reversibile.

Ogni file in una directory assume uno dei questi due stati:
\emph{untracked} (non tracciato) o \emph{tracked} (tracciato).
Un file è \emph{untracked} se non è stato mai aggiunto ad una repository o se è stato
aggiunto ma poi rimosso dalla lista dei file tracciati (comando \textsf{rm}).
Un file \emph{tracked}, ovvero l’esatto opposto di un \emph{untracked}, può essere a sua volta in tre
stati: \emph{unmodified} (non modificato o \emph{committed}), \emph{modified} (modificato) e \emph{staged}.
Un file \emph{tracked} è \emph{unmodified} quando coincide con la sua ultima versione nel database.
Se qualsiasi cambiamento avviene, diventa \emph{modified}.
Per diventare \emph{staged} è necessario che l’utente utilizzi su di lui il comando \textsf{add},
in questo modo esso viene viene inserito (o aggiornato se era già presente) nella \emph{staging area}
(o \emph{index}) della repository, essa contiene tutti i file tracciati della repository con una flag
che indica se sono stati modificvati o meno dall’ultimo snapshot.
L’operazione di \emph{commit} (comando \textsf{commit}) crea un nuovo snapshot che incorpora
tutti i cambiamenti specificati nella staging area e lo immagazzina nel suo database locale.
A questo punto la staging area verrà ripulita (\emph{cleaned}).
Gli utenti Git possono condividere informazioni e collaborare tra di loro tramite repository remote
su server Git che possono essere sincronizzate con le loro repository locali.

Le operazioni di \emph{pull}, \emph{push}, \emph{clone} e \emph{fetch}
sono tipiche quando si lavora con repository remote.
Il comando \textsf{clone} crea una copia esatta di una repository target,
incluso il suo database di snapshot.
Il comando \textsf{fetch} permette di scaricare le risorse di un progetto remoto che non sono
presenti in quello locale, senza però andare a modificare i file già presenti
applicando eventuali modifiche.
Il comando \textsf{pull} è simile a \textsf{fetch}, eccetto che tenta di eseguire una fusione
automatica del file remoto e del file locale applicando a quest’ultimo le modifiche più recenti.
Infine, il comando \textsf{push} consente di inviare ogni nuovo commit locale al sevrer remoto,
in modo da mantenerli sincronizzati.


\section{Blockchain ed Ethereum}
\label{sub:bc}
Una \textbf{blockchain}~\cite{block1}~\cite{block2} è un registro condiviso e immutabile che facilita il processo di registrazione
delle transazioni e di tracciamento degli asset in una rete di business. Un asset è un qualsiasi
elemento avente un valore, esso può essere rintracciato e scambiato su una rete blockchain,
riducendo i rischi e i costi per tutti gli interessati. Ogni volta che un asset viene registrato e
ne viene dunque registrata la sua transazione, essa prende la forma di un blocco,
il nome della tecnologia deriva dal fatto che questo registro è essenzialmente una serie di blocchi
collegati sequenzialmente in maniera irreversibile, come una catena.
Gli elementi chiave di una blockchain sono il registro distribuito e accessibile a chiunque faccia
parte della stessa rete dove le transazioni vengono registrate un’unica volta, dei record immutabili
che non permettono ad alcun partecipante alla rete di poter essere modificati o manomessi,
anche in presenza di errori, e infine, anche se assenti da alcune reti come quella Bitcoin,
la presenza dei cosiddetti \textbf{Smart Contract} \label{sub:smp}, ovvero dei set di regole programmabili che permettono
anche la creazione di vere e proprie applicazioni che operano
sul registro leggendo e aggiungendo nuovi blocchi alla catena. \\
I vantaggi di questa tecnologia sono di certo non trascurabili, soprattutto in tempi
recenti con l’aumento esponenziale della quantità di transazioni che vengono eseguite
sia nelle reti pubbliche sia nelle private.
In un sistema centralizzato abbiamo uno spreco di risorse per la convalida di terze parti
e per la memorizzazione di record duplicati, aspetti assenti in una rete dotata di blockchain
dove chiunque è sicuro che nessuna transazione è stata eliminata o manomessa e si fida della
validità dei dati confidando nel fatto che ogni partecipante ha la copia esatta e sincronizzata
del registro nella sua macchina.
Questa tecnologia può sicuramente essere implementata all’interno di un’azienda ed essere privata,
l’incentivo a mantenere la sua esistenza è il profitto a cui un corretto utilizzo di essa può portare
con un incremento della produttività e un minore utilizzo di risorse.
Tuttavia il mantenimento di una blockchain pubblica e accessibile a tutti richiede un incentivo,
un insieme distribuito di individui deve mettere a disposizione parte della potenza computazionale
e dell’archivio della propria macchina per permettere a questo registro di esistere
e alle transazioni di essere eseguite e calcolate correttamente.
Non a caso la tecnologia della blockchain è nata assieme a quella delle criptovalute:
essa doveva avere lo scopo di “libro mastro” proprio per Bitcoin, mantenendosi grazie a persone
disposte a mettere a disposizione il proprio hardware in cambio di un compenso
proprio  nella criptovaluta della rete.


\label{sub:eth}
Nasce da queste tecnologie il progetto \textbf{Ethereum}~\cite{eth-21}~\cite{eth-22}, con l’obiettivo di mettere però
più carne al fuoco: esso trascende il concetto di semplice criptovaluta andando a creare
una piattaforma decentralizzata per la creazione e la pubblicazione peer-to-peer di Smart Contract
in linguaggi di programmazione Turing completi (ovvero capaci di risolvere ogni problema
che gli si possa presentare): Solidity e Vyper.
Con Ethereum è quindi possibile andare a creare vere e proprie applicazioni
con vita propria all’interno della \textbf{Ethereum Virtual Machine},
ovvero la grande macchina virtuale simulata andando ad unire tutta la potenza computazionale
messa a disposizione dagli utenti di Ethereum e usando la blockchain come archivio di
informazioni permanenti. Ovviamente sia la pubblicazione di uno Smart Contract sia la registrazione
in generale di informazioni sulla blockchain all’interno di reti pubbliche come quella
thereum ha un costo pecuniario proporzionale alla quantità di informazioni che si andranno a registrare.

\section{Accumulatori crittografici e Merkle Tree}
\label{sub:mt}
I \textbf{Merkle Tree}~\cite{mertree} sono una tipologia di \textbf{accumulatori crittografici}, ovvero strumenti che permettono
di comprimere molti elementi informativi in una costante di dimensione fissa, in altre parole
ci permettono di rappresentare più blocchi di dati con un singolo hash.
Nel particolare, i Merkle Tree, nello specifico quelli binari, sono essenzialmente alberi binari
in cui ogni foglia corrisponde all’hash di uno dei nostri elementi, risalendo verso la radice ogni
nodo interno calcolerà il proprio hash concatenando gli hash dei nodi figli, infine si avrà
una radice (\textbf{Merkle Root} o MR) il cui hash è univoco a quella lista di hash che l’albero
ha come foglie, in quella sequenza.
Inoltre, utilizzando degli hash generati con una funzione crittografica “forte”, si ha
un’assenza di collisioni tra le Merkle Root.
Perciò sappiamo che, per una determinata sequenza di documenti, anche solo una
piccola modfica ad un file causerebbe il cambiamento totale della MR.

Possiamo quindi capire che c’è stato un cambiamento, tuttavia per capire anche
quale dei documenti è stato cambiato bisogna ricorrere al concetto di \textbf{Merkle Proof}.
Per effettuare una verifica tramite Merkle Proof sono tre gli elementi necessari:
\begin{enumerate}
    \item L’elemento (foglia) che vogliamo verificare
    \item La Merkle Root
    \item La Merkle Proof, ovvero la lista degli hash dei fratelli lungo il cammino dall’elemento alla matrice
\end{enumerate}
Andando a svolgere questa verifica su ogni documento riusceremo ad individuare i file modificati come
quelli per cui non è possibile ricostruire il cammino verso la radice lasciandola inalterata.


\section{JSON}
\label{sub:json}
Il JavaScript Object Notation (\textbf{JSON})~\cite{json} è un semplice formato per lo scambio di dati,
facile da interpretare e capire sia per i vari linguaggi di programmazione che per gli esseri umani.
Esso, con le librerie apposite per ogni linguaggio, permette un semplice e rapido scambio
di dati tra più applicativi e fornisce metodologie per la conversione di oggetti e collezioni
di dati strutturati in stringhe da salvare in file e viceversa, un’ottima alternativa ai database
per applicazioni che cercano di sviluppare architetture distribuite.
