Di seguito si introducono alcuni concetti 
per permettere al lettore di acquisire le nozioni necessarie alla
corretta fruizione del materiale successivo.

\section{Funzioni di hash}
\label{sub:hash}
Una \textbf{funzione di hashing} \(h\) è una funzione che permette di associare,
a una qualsiasi sequenza \(m\) di lunghezza arbitraria in input, una sequenza
in output \(h(m)\) di lunghezza costante. 
Questo valore restituito in output è chiamato valore di hash, stringa di hash,
o anche semplicemente \textbf{hash}, mentre il valore preso in input è detto
\textbf{preimmagine}. Possiamo pensare a questa funzione come una “macchina per
impronte digitali”, per ogni sequenza in input essa riesce a calcolarne una stringa binaria
che la identifica univocamente.

Una funzione di hash ha tre caratteristiche fondamentali:
innanzitutto è \emph{deterministica}, ciò significa che per lo stesso input essa deve
generare sempre lo stesso output, deve poi generare esclusivamente
\emph{sequenze in output con una lunghezza fissa}, ciò significa che per qualsiasi input
di qualsiasi lunghezza il risultato dovrà avere sempre una lunghezza di \(b\) bit decisa
a priori, infine deve essere \emph{uniforme}, ovvero i suoi output dovrebbero essere
uniformemente distribuiti nel codominio della funzione.
Una stringa di hash, essendo una sequenza binaria, può essere rappresentata in molti modi,
nell’ambito di questo documento presenteremo i vari hash come stringhe esadecimali.

Mentre una funzione di hash classica è tranquillamente utilizzabile per situazioni
in cui non è necessaria una particolare sicurezza nel proteggere le caratteristiche
delle preimmagine, ragion per cui si può decidere, nel progettarla, di prestare più
attenzione verso la sua rapidità d’esecuzione che altro, quando si ha bisogno che le
informazioni in input rimangano nascoste e si necessita di una maggior sicurezza a scapito
della velocità si ricorre alle \textbf{funzioni crittografiche di hash}.

Una funzione crittografica di hash ha le stesse caratteristiche di una funzione di
hash normale ma aggiunge delle proprietà che deve seguire per poter essere considerata
\emph{crittograficamente sicura}, i valori della sua lunghezza b sono tipicamente
128, 256 e 512, si va quindi ad ottenere degli output potenzialmente molto più lunghi
e che non sembrano adatti alle implementazioni all’interno di semplici strutture dati
per cui le classiche funzioni di hash sono designate.

Le proprietà che permettono di definire una funzione crittografica di hash come sicura sono:
\begin{enumerate}
    \item \emph{Resistenza alla preimmagine}: Dato un hash \(h\) deve essere difficile riuscire a
    trovare un input \(m\) tale che \(h = h(m)\).
    \item \emph{Resistenza alla seconda preimmagine}: Dato un input \(m_1\) deve essere difficile
    riuscire a trovare un diverso input \(m_2\) tale che \(h(m_1) = h(m_2)\).
    \item \emph{Resistenza alla collisione}: Dati due messaggi \(m_1\) ed \(m_2\), deve essere
    difficile che i due messaggi abbiano lo stesso hash, quindi con \(h(m_1) = h(m_2)\).
\end{enumerate}
Queste proprietà ci permettono di arrivare a concludere che una funzione crittografica di
hash effettua un’operazione unidirezionale: non è possibile (o perlomeno non dovrebbe esserlo),
partendo dal singolo hash, risalire alla preimmagine. \\
Per riuscire a mantenere tali proprietà la funzione, durante la fase di generazione
dell’output, effettua diverse e differenti operazioni sulla preimmagine
che fanno si che anche un solo minuscolo cambiamento all’input generi
un \emph{effetto valanga} sull’output, cambiando radicalmente, se non completamente,
l’hash generato.

Le funzioni crittografiche di hash vengono utilizzate in moltissime implementazioni
nell’ambito della cybersecurity come la verifica di password, la generazione e
validazione di firme digitali e la \textbf{verifica d’integrità di file}.
Quest’ultima assume un’importanza fondamentale anche nel nostro caso: queste funzioni
ci permettono di capire se, dati due file, il loro contenuto è identico senza
la necessità di effettuare alcun controllo byte per byte in quanto produrranno
lo stesso valore di hash, in questo modo possiamo anche capire se un file,
che durante un controllo generava un determinato valore, è stato modificato,
ciò perché il valore generato sarà ovviamente differente.



\section{VCS e Git}
\label{sub:vcs}
Un \textbf{Version Control System}~\cite{vcs1} (o anche VCS), in italiano “sistema di controllo di versione”,
è una tipologia di software per la condivisione,
il controllo e la tracciabilità dei cambiamenti riguardanti determinati file e directory
lungo un lasso di tempo e che permette agli utenti di recuperare rapidamente specifiche
versioni dei loro documenti. Gli insiemi di file e cartelle gestite da questi sistemi
sono suddivisi in \textbf{repository}, esse vengono trattate l’una isolata dalle altre.
Spesso si considera una intera directory di lavoro, con il suo contenuto,
un’unica repository, potendo però scegliere di escludere alcune risorse.
Un VCS può essere centralizzato o distribuito~\cite{vcs2}.
Nel primo caso è il server centrale che tiene traccia dei cambiamenti e che mantiene e
distribuisce la versione più recente delle risorse richieste, gli utenti possono gestire
le loro repository solo attraverso client lightweight che interagiscono con il server
per riuscire a compiere una qualsiasi operazione.
Nel secondo caso ogni client ha una copia precisa della repository e del suo storico
salvata localmente, i server sono coinvolti solo per effettuare sincronizzazioni
di repository tra i vari client.
\\ 
\label{sub:git}
\textbf{Git}~\cite{git-21} è il sistema di controllo di versione distribuito più diffuso al mondo.
Esso modella ogni repository come una \emph{sequenza} o \emph{flusso di snapshot} (istantanee)
di un piccolo file system. Ogni volta che un utente salva lo stato del suo progetto
(tramite l’operazione di \emph{commit}) Git crea uno snapshot di tutti i file e le directory
sotto controllo di versione in quel momento e la archivia nel suo database locale, ogni
file modificato dall’ultimo commit viene incluso nell’ultimo snapshot, mentre i file che
non sono stati modificati non vengono inclusi se non con un collegamento alla loro versione identica
nel commit precedente, in modo da evitare alcuna duplicazione non necessaria.
Ogni risorsa in una repository è identificata internamente dal suo hash (\autoref{sub:hash}) e non dal suo nome,
questo permette a Git di individuare efficientemente i cambiamenti nei file.
Inoltre, quasi ogni operazione di Git va ad aggiungere informazioni al suo database, anche se si tratta
di un’operazione di rimozione, ciò assicura che ogni cambiamento sia reversibile.

Ogni file in una directory assume uno dei questi due stati:
\emph{untracked} (non tracciato) o \emph{tracked} (tracciato).
Un file è \emph{untracked} se non è stato mai aggiunto ad una repository o se è stato
aggiunto ma poi rimosso dalla lista dei file tracciati (comando \textsf{rm}).
Un file \emph{tracked}, ovvero l’esatto opposto di un \emph{untracked}, può assumere a sua volta uno di questi tre
stati: \emph{unmodified} (non modificato o \emph{committed}), \emph{modified} (modificato) e \emph{staged}.
Un file \emph{tracked} è \emph{unmodified} quando coincide con la sua ultima versione nel database.
Se qualsiasi cambiamento avviene, diventa \emph{modified}.
Per diventare \emph{staged} è necessario che l’utente utilizzi su di lui il comando \textsf{add},
in questo modo esso viene viene inserito (o aggiornato se era già presente) nella \emph{staging area}
(o \emph{index}) della repository, essa contiene tutti i file tracciati della repository con una flag
che indica se sono stati modificati o meno dall’ultimo snapshot.
L’operazione di \emph{commit} (comando \textsf{commit}) crea un nuovo snapshot che incorpora
tutti i cambiamenti specificati nella staging area e lo immagazzina nel suo database locale.
A questo punto la staging area verrà ripulita (\emph{cleaned}).
Gli utenti Git possono condividere informazioni e collaborare tra di loro tramite repository remote
su server Git che possono essere sincronizzate con le loro repository locali.

Le operazioni di \emph{pull}, \emph{push}, \emph{clone} e \emph{fetch}
sono tipiche quando si lavora con repository remote.
Il comando \textsf{clone} crea una copia esatta di una repository target,
incluso il suo database di snapshot.
Il comando \textsf{fetch} permette di scaricare le risorse di un progetto remoto che non sono
presenti in quello locale, senza però andare a modificare i file già presenti
applicando eventuali modifiche.
Il comando \textsf{pull} è simile a \textsf{fetch}, eccetto che tenta di eseguire una fusione
automatica del file remoto e del file locale applicando a quest’ultimo le modifiche più recenti.
Infine, il comando \textsf{push} consente di inviare ogni nuovo commit locale al sevrer remoto,
in modo da mantenerli sincronizzati.


\section{Blockchain ed Ethereum}
\label{sub:bc}
Una \textbf{blockchain}~\cite{block1}~\cite{block2} è un registro condiviso e immutabile che facilita il processo di registrazione
delle transazioni e di tracciamento degli asset in una rete aziendale e non. Un asset è un qualsiasi
elemento avente un valore, esso può essere rintracciato e scambiato su una rete blockchain,
riducendo i rischi e i costi per tutti gli interessati. Ogni volta che un asset viene registrato e
ne viene in realtà registrata la transazione che si riferisce ad esso, essa prende la forma di un blocco,
il nome della tecnologia deriva dal fatto che questo registro è essenzialmente una serie di blocchi
collegati sequenzialmente in maniera irreversibile, come una catena.
Gli elementi chiave di una blockchain sono l’effettivo registro distribuito e accessibile a chiunque faccia
parte della stessa rete, dove le transazioni vengono registrate un’unica volta, dei record immutabili
che non permettono ad alcun partecipante alla rete di poter essere modificati o manomessi,
anche in presenza di errori, e infine, anche se assenti da alcune reti come quella Bitcoin,
la presenza dei cosiddetti \textbf{Smart Contract} \label{sub:smp}, ovvero dei set di regole programmabili che permettono
anche la creazione di vere e proprie applicazioni che operano
sul registro leggendo e aggiungendo nuovi blocchi alla catena. \\ 
I vantaggi di questa tecnologia sono di certo non trascurabili, soprattutto in tempi
recenti con l’aumento esponenziale della quantità di transazioni che vengono eseguite
sia nelle reti pubbliche sia nelle private.
In un sistema centralizzato abbiamo uno spreco di risorse per la convalida di terze parti
e per la memorizzazione di record duplicati, aspetti assenti in una rete dotata di blockchain
dove chiunque è sicuro che nessuna transazione è stata eliminata o manomessa e si fida della
validità dei dati confidando nel fatto che ogni partecipante ha la copia esatta e sincronizzata
del registro nella sua macchina.
Questa tecnologia può essere implementata senza problemi all’interno di un’azienda ed essere privata,
l’incentivo a mantenere la sua esistenza è il profitto a cui un corretto utilizzo di essa può portare
con un incremento della produttività e un minore utilizzo di risorse.
Tuttavia il mantenimento di una blockchain pubblica e accessibile a tutti richiede un incentivo,
un insieme distribuito di individui deve mettere a disposizione parte della potenza computazionale
e dell’archivio della propria macchina per permettere a questo registro di esistere
e alle transazioni di essere eseguite e calcolate correttamente.
Non a caso la tecnologia della blockchain è nata assieme a quella delle criptovalute:
essa doveva avere lo scopo di “libro mastro” per Bitcoin, mantenendosi grazie a persone
disposte a mettere a disposizione il proprio hardware in cambio di un compenso
nella criptovaluta propria della rete.


\label{sub:eth}
Nasce da queste tecnologie il progetto \textbf{Ethereum}~\cite{eth-21}~\cite{eth-22}, con l’obiettivo di mettere però
più carne al fuoco: esso trascende il concetto di semplice criptovaluta andando a creare
una piattaforma decentralizzata per la creazione e la pubblicazione peer-to-peer di Smart Contract
in linguaggi di programmazione Turing completi (ovvero capaci di risolvere ogni problema
che gli si possa presentare): Solidity e Vyper.
Con Ethereum è quindi possibile andare a creare vere e proprie applicazioni
con vita propria all’interno della \textbf{Ethereum Virtual Machine},
ovvero la grande macchina virtuale simulata andando ad unire tutta la potenza computazionale
messa a disposizione dagli utenti di Ethereum e usando la blockchain come archivio di
informazioni permanenti. Ovviamente sia la pubblicazione di uno Smart Contract sia la registrazione
in generale di informazioni sulla blockchain all’interno di reti pubbliche come quella
Ethereum ha un costo pecuniario proporzionale alla quantità di dati che si andranno a registrare.

\section{Accumulatori crittografici e Merkle Tree}
\label{sub:mt}
I \textbf{Merkle Tree}~\cite{mertree} sono una tipologia di \textbf{accumulatori crittografici}, ovvero strumenti che permettono
di comprimere molti elementi informativi in una costante di dimensione fissa, in altre parole
ci permettono di rappresentare più blocchi di dati con un singolo hash.
I Merkle Tree, nello specifico quelli binari, sono essenzialmente alberi binari
in cui ogni foglia corrisponde all’hash di uno dei nostri elementi, risalendo verso la radice ogni
nodo interno calcolerà il proprio hash concatenando gli hash dei nodi figli, infine si avrà
una radice (\textbf{Merkle Root} o MR) il cui hash è univoco a quella lista di elementi che l’albero
ha come foglie, in quella sequenza.
Inoltre, utilizzando degli hash generati con una funzione crittografica “forte”, si ha
un’assenza di collisioni tra le Merkle Root.
Perciò sappiamo che, per una determinata sequenza di documenti, anche solo una
piccola modfica ad un file causerebbe un cambiamento significativo, se non totale, della MR.

Possiamo quindi capire che c’è stato un cambiamento, tuttavia per capire anche
quale dei documenti è stato cambiato bisogna ricorrere al concetto di \textbf{Merkle Proof}.
Per effettuare una verifica tramite Merkle Proof sono tre gli elementi necessari:
\begin{enumerate}
    \item L’elemento (foglia) che vogliamo verificare
    \item La Merkle Root
    \item La Merkle Proof, ovvero la lista degli hash dei fratelli lungo il cammino dall’elemento alla matrice
\end{enumerate}
Andando a svolgere questa verifica su ogni documento riusceremo ad individuare i file modificati come
quelli per cui non è possibile ricostruire il cammino verso la radice lasciandola inalterata.

\newpage

\section{JSON}
\label{sub:json}
Il JavaScript Object Notation (\textbf{JSON})~\cite{json} è un semplice formato per lo scambio di dati,
facile da interpretare e capire sia per i vari linguaggi di programmazione che per gli esseri umani.
Esso, con le librerie apposite per ogni linguaggio, permette un semplice e rapido scambio
di dati tra più applicativi e fornisce metodologie per la conversione di oggetti e collezioni
di dati strutturati in stringhe da salvare in file e viceversa, un’alternativa ragionevole ai database
per applicazioni che cercano di sviluppare architetture distribuite.
